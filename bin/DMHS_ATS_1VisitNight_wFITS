#!/usr/bin/env python

import time
import sys
import os
import logging
import HeaderService
import salpytools
import HeaderService.hutils as hutils
import argparse
import socket
import math
    
spinner = hutils.spinner

def cmdline():

    # Make conf_parser that hold values from a config.ini file
    parser = argparse.ArgumentParser(description="DM Header Service")
    parser.add_argument("--vendor", action="store",default='ITL', 
                        help="CCD Vendor Name")
    parser.add_argument("--filepath", action="store",default=os.path.join(os.getcwd(),'DMHS_filerepo'),
                        help="Filepath where we write the headers")
    parser.add_argument("--tsleep", action="store",default=0.1, type=float, 
                        help="Sleep Time for loop")
    parser.add_argument("--start_state", action="store",default=None, 
                        help="Initial start State of device")
    parser.add_argument("--send_efd_message", action="store_true",default=False, 
                        help="Send and EDF message as well?")
    args = parser.parse_args()
    return args

def run_enable(State,vendor='ITL',filepath='.',tsleep=0.1, start_state='OFFLINE'):

    # Subscribe to all channel from where we want Telem/Events, eventually this will
    # be governed by a configuration file
    StartInt = salpytools.DDSSubcriber("atcamera","startIntegration",Stype="Event")
    EndTelem = salpytools.DDSSubcriber("atcamera","endOfImageTelemetry",Stype="Event")
    Exptime  = salpytools.DDSSubcriber("atcamera","shutterMotionProfile",Stype="Event")
    ImParam  = salpytools.DDSSubcriber("atcamera","imageReadoutParameters",Stype="Event")
    Target   = salpytools.DDSSubcriber("atScheduler", "target",Stype="Event")

    # And the object to send DMHS messages
    dmhs = salpytools.DDSSend("atHeaderService")
    efd  = salpytools.DDSSend('efd')
        
    StartInt.start()
    EndTelem.start()
    Exptime.start()
    Target.start()
    ImParam.start()
    
    # Load up the header template
    HDR = HeaderService.HDRTEMPL_ATSCam(vendor=vendor)
    HDR.load_templates()
    LOGGER = HDR.logger

    # Make sure that we have a place to put the files
    if not os.path.exists(filepath):
        os.makedirs(filepath)
        LOGGER.info("Created dirname:{}".format(filepath))

    # Get the hostname and IP address
    ip_adress = socket.gethostbyname(socket.gethostname())
    # The user running the process
    USER = os.environ['USER']
    # The protocol
    PROTOCOL = 'scp'
    
    # For testing start ENABLE
    loop_n = 0
    while True:

        if State.current_state!='ENABLE':
            sys.stdout.flush()
            sys.stdout.write("Current State is {} [{}]".format(State.current_state,spinner.next()))
            sys.stdout.write('\r') 

        elif StartInt.newEvent:

            # Build the DATE of observation
            DATE_OBS = hutils.get_date_utc()

            sys.stdout.flush()
            LOGGER.info("Received: startIntegration Event")
            LOGGER.info("Extracting value for imageName")
            myData = StartInt.getCurrent()
            imageName = myData.imageName
            exptime = myData.exposureTime
            LOGGER.info("Received: imageName={}, exptime={}".format(imageName,exptime))

            # Construct the hdr and fits filename
            filename_HDR  = os.path.join(filepath,"{}.header".format(imageName))
            filename_FITS = "{}.fits".format(imageName)

            # Get the Target information
            LOGGER.info("Extracting Target information")
            myData = Target.getCurrent()
            ra,dec,angle,airmass = myData.ra, myData.decl, myData.angle, myData.airmass
            LOGGER.info("Received: RA={}, DEC={}, ANGLE={}, AIRMASS={}".format(ra,dec,angle,airmass))
            filter_name, grating = myData.filters, myData.grating
            LOGGER.info("Received: filter={}, grating={}".format(filter_name,grating))
            # For now -- we try to recover the zenith distance from the airmass 
            try:
                zd = (math.acos(1.0/airmass))*180./math.pi
            except:
                zd = -99.0

            # Get the readout
            LOGGER.info("Current State is {} -- waiting for Camera endOfImageTelemetry event".format(State.current_state))
            EndTelem.waitEvent()
            if EndTelem.newEvent:
                sys.stdout.flush()
                LOGGER.info("Received: endOfImageTelemetry Signal")

                # We get these after we get endOfImageTelemetry Signal
                # Exposure Time
                LOGGER.info("Extracting Actual Exposure time")
                myData = Exptime.getCurrent()
                measuredExptime = myData.measuredExposureTime
                LOGGER.info("Received: measuredExptime={}".format(measuredExptime))

                # Image paramters
                LOGGER.info("Extracting Image Parameters")
                myData = ImParam.getCurrent()
                # in case we want to get NAXIS1/NAXIS2, etc.
                geom = hutils.get_image_size_from_imageReadoutParameters(myData)
                #overv, overh, preh = myData.overRows, myData.overCols,myData.preRows
                LOGGER.info("Received: overv={}, overh={}, preh={}".format(geom['overv'], geom['overh'], geom['preh']))
                # We update the headers and reload them
                HDR.CCDGEOM.overh = geom['overh']
                HDR.CCDGEOM.overv = geom['overv']
                HDR.CCDGEOM.preh  = geom['preh']
                LOGGER.info("Reloadling templates")
                HDR.load_templates()
                LOGGER.info("For reference NAXIS1:{}".format(geom['NAXIS1']))
                LOGGER.info("For reference NAXIS2:{}".format(geom['NAXIS2']))

                # Manually Update a header param -- we need to move it a function soon
                # These ones were captured from DDS
                HDR.update_record('FILTER',filter_name, 'PRIMARY')
                HDR.update_record('GRATING',grating, 'PRIMARY')
                HDR.update_record('RA',ra,'PRIMARY')
                HDR.update_record('DEC',dec,'PRIMARY')
                HDR.update_record('ROTANGLE',angle,'PRIMARY')
                HDR.update_record('AIRMASS',airmass,'PRIMARY')
                HDR.update_record('RATEL',ra,'PRIMARY')
                HDR.update_record('DECTEL',dec,'PRIMARY')
                HDR.update_record('ZD', zd, 'PRIMARY')
                HDR.update_record('IMGNAME',imageName,'PRIMARY')
                HDR.update_record('EXPTIME',measuredExptime,'PRIMARY')
                HDR.update_record('OVERH',geom['overh'],'PRIMARY')
                HDR.update_record('OVERV',geom['overv'],'PRIMARY')
                HDR.update_record('PREH',geom['preh'],'PRIMARY')
                # These values are computed by the DMHS
                HDR.update_record('FILENAME',filename_FITS,'PRIMARY')
                HDR.update_record('DATE-OBS',DATE_OBS.fits,'PRIMARY')
                HDR.update_record('MJD-OBS',DATE_OBS.mjd,'PRIMARY')
                # The creation date -- now!!
                DATE = hutils.get_date_utc()
                HDR.update_record('DATE',DATE.fits,'PRIMARY')
                HDR.update_record('MJD',DATE.mjd,'PRIMARY')
                # The obs-nite
                HDR.update_record('OBS-NITE',hutils.get_obsnite(),'PRIMARY')
                # Write the header 
                HDR.write_header(filename_HDR, newline=False)
                LOGGER.info("Wrote header to: {}".format(filename_HDR))
                # Get the md5 for the header file
                md5value = hutils.md5Checksum(filename_HDR) #,blocksize=1024*512):
                bytesize = os.path.getsize(filename_HDR)
                LOGGER.info("Got MD5SUM: {}".format(md5value))
                # Now we publish filename and MD5
                # Build the kwargs
                kw = {'Byte_Size':bytesize,
                      'Checksum':md5value,
                      'Generator':'AT',
                      'Mime':'FITS',
                      'URL': "{}://{}@{}:{}".format(PROTOCOL,USER,ip_adress,filename_HDR),
                      #'URL': "{}".format(os.path.abspath(filename_HDR)),
                      'Version': 1,
                      'priority':1,
                      }
                dmhs.send_Event('LargeFileObjectAvailable',**kw)
                LOGGER.info("Sent LargeFileObjectAvailable: {}".format(kw))
                if args.send_efd_message:
                    efd.send_Event('LargeFileObjectAvailable',**kw)
                EndTelem.newEvent = False
                LOGGER.info("------------------------------------------")

        else:
            sys.stdout.flush()
            sys.stdout.write("Current State is {} -- wating for startIntegration Event...[{}]".format(State.current_state,spinner.next()))
            sys.stdout.write('\r')
            time.sleep(tsleep)

        time.sleep(tsleep)
        loop_n +=1    

if __name__ == "__main__":

    # Get the args from the command-line
    args = cmdline()

    # Init the device and send the current state vis SummaryState.
    # This needs to be done before we star the SAL controller thread,
    # as they use the DeviveState object for the current state
    State = salpytools.DeviceState()
    State.send_logEvent('SummaryState')
    
    # Create threads for the controller we want to listen to
    controller_list = ['enterControl',
                       'exitControl',
                       'start',
                       'standby',
                       'enable',
                       'disable']
    tControl = {}
    for ctrl_name in controller_list:
        tControl[ctrl_name] = salpytools.DDSController(ctrl_name,State=State)
        tControl[ctrl_name].start()

    # Set the initial state
    if args.start_state:
        State.current_state = args.start_state

    run_enable(State,vendor=args.vendor,filepath=args.filepath,tsleep=args.tsleep)
    
