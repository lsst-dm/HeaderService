#!/usr/bin/env python3

import time
import argparse
import salpytools
import HeaderService.hutils as hutils
import HeaderService.hscalc as hscalc
import HeaderService.camera_coords as camera_coords
import random

LOGGER = hutils.create_logger()


# Get the info from the camera_coords library for and E2V sensor
_GEO = camera_coords.CCDGeom('E2V')


def cmdline():

    # Make conf_parser that hold values from a config.ini file
    parser = argparse.ArgumentParser(description="Send telemetry to Header Client")

    # The command-line arguments
    parser.add_argument("--ra", action="store", default=None, type=float,
                        help="The RA of the visit")
    parser.add_argument("--dec", action="store", default=None, type=float,
                        help="The DEC of the visit")
    parser.add_argument("--rotpa", action="store", default=0.0, type=float,
                        help="The ROTPA for the visit")
    parser.add_argument("--filter", action="store", default='r',
                        help="Name of the filter")
    parser.add_argument("--grating", action="store", default='R400',
                        help="Name of the grating")
    parser.add_argument("--imageSequenceName", action="store", default='LSSTTEST',
                        help="ImageSequenceName")
    # Control imageName
    parser.add_argument("--telcode", action="store", default='AT',
                        help="The code for the telecope")
    parser.add_argument("--controller", action="store", default='O',
                        help="The controller (O for OCS, C for CCS)")
    parser.add_argument("--dayobs", action="store", default=None,
                        help="The observation day as defined by image name")
    parser.add_argument("--seqnum", action="store", default=1, type=int,
                        help="The sequence number from the image name")
    parser.add_argument("--NSequence", action="store", default=3, type=int,
                        help="Number of exposure in sequence")

    parser.add_argument("--exptime", action="store", default=15, type=float,
                        help="Exposure time in seconds")
    parser.add_argument("--airmass", action="store", default=1.237, type=float,
                        help="Airmass")
    parser.add_argument("--ha", action="store", default='30.0', type=str,
                        help="The HA")
    parser.add_argument("--el", action="store", default=75.0, type=float,
                        help="The elevation angle")
    parser.add_argument("--az", action="store", default=45.0, type=float,
                        help="The azimuth angle")

    parser.add_argument("--sleeptime", action="store", default=1, type=float,
                        help="Sleep Time between step, in seconds")
    parser.add_argument("--preh", action="store", default=_GEO.preh, type=int,
                        help="prescan horizontal")
    parser.add_argument("--overh", action="store", default=_GEO.overh, type=int,
                        help="overscal horizontal")
    parser.add_argument("--overv", action="store", default=_GEO.overv, type=int,
                        help="overscal vertical")
    args = parser.parse_args()
    return args


if __name__ == "__main__":

    # Get the args from the command-line
    args = cmdline()

    # Initialize the classes for each device
    # Note that we need a separate object for Commands if we want to wait
    ptg = salpytools.DDSSend("ATPtg")
    cam = salpytools.DDSSend("ATCamera")
    mcs = salpytools.DDSSend("ATMCS")
    spec = salpytools.DDSSend("ATSpectrograph")
    # camCommand = salpytools.DDSSend("camera")
    camCommand = cam

    # Camera Geometry
    # Send sub-set of imageReadoutParameters, we populate only a few fields
    kw = {'overRows': args.overv,
          'overCols': args.overh,
          'preCols': args.preh,
          'readCols': _GEO.dimh,
          'readCols2': 0,
          'readRows': _GEO.dimv,
          }
    cam.send_Event('imageReadoutParameters', **kw)

    # Poiting information
    # Send the pointing event -- here we populate only a few fields
    # from: "ATPtg_logevent_currentTarget"
    kw = {'timestamp': time.time(),
          'ra': args.ra,
          'declination': args.dec,
          'rotPA': args.rotpa,
          'priority': 1}
    ptg.send_Event('currentTarget', **kw)
    LOGGER.info("Sending currentTarget\n {}".format(ptg.get_myData()))

    # Filter information for ATSpectrograph
    kw = {'timestamp': time.time(),
          'name': args.filter,
          'position': 1,  # Made up
          'priority': 1}
    spec.send_Event('reportedFilterPosition', **kw)
    LOGGER.info("Sending reportedFilterPosition\n {}".format(spec.get_myData()))

    # Disperser information for ATSpectrograph
    kw = {'timestamp': time.time(),
          'name': args.grating,
          'position': 2,  # Made up
          'priority': 1}
    spec.send_Event('reportedDisperserPosition', **kw)
    LOGGER.info("Sending reportedDisperserPosition\n {}".format(spec.get_myData()))

    # Linear Stage position
    kw = {'timestamp': time.time(),
          'name': args.grating,
          'position': 2,  # Made up
          'priority': 1}
    spec.send_Event('reportedLinearStagePosition', **kw)
    LOGGER.info("Sending reportedLinearStagePosition\n {}".format(spec.get_myData()))

    # Send the takeImages command
    kw = {'numImages': args.NSequence,
          'expTime': args.exptime,
          'imageSequenceName': args.imageSequenceName,
          'timeout': 10}

    camCommand.send_Command('takeImages', **kw)
    LOGGER.info("Sending takeImages {}:\n".format(camCommand.get_myData()))
    # camCommand.start()

    LOGGER.info("---Starting Image loop---")

    # Loop over nsequence
    for k in range(args.NSequence):

        timeStamp = time.time()
        seqN = args.seqnum + k
        LOGGER.info("----Starting Integration {}".format(seqN))

        # We need to emulate this format from camera:
        # AT_O_20190409_000008.header
        if args.dayobs:
            DAYOBS = args.dayobs
        else:
            DATE_OBS = hscalc.get_date_utc(timeStamp)
            DAYOBS = DATE_OBS.datetime.strftime('%Y%m%d')
        imageName = "{}_{}_{}_{:06d}".format(args.telcode, args.controller, DAYOBS, seqN)

        # send CCD temperature telemetry
        kw = {'timestamp': time.time(),
              'ccdTemp0': random.uniform(-30, 0)}
        cam.send_Telemetry('wreb', **kw)
        LOGGER.info("Sending wreb {}:\n".format(cam.get_myData()))

        # start telemetry for Airmass using ATPtg.prospectiveTargetStatus
        kw = {'timestamp': time.time(),
              'ha': args.ha,
              'airmass': args.airmass}
        ptg.send_Telemetry('prospectiveTargetStatus', **kw)
        LOGGER.info("Sending prospectiveTargetStatus {}:\n".format(ptg.get_myData()))

        # start telemetry for EL and AZ from the ATMCS.mountEncoders
        kw = {'timestamp': time.time(),
              'elevationCalculatedAngle': args.el,
              'azimuthCalculatedAngle': args.az}
        mcs.send_Telemetry('mountEncoders', **kw)
        LOGGER.info("Sending mountEncoders {}:\n".format(mcs.get_myData()))

        # Send startIntegration k
        LOGGER.info("Sending starIntegration")
        kw = {'imageSequenceName': args.imageSequenceName,
              'imageName': imageName,
              'imageIndex': k+1,
              'timeStamp': timeStamp,
              'exposureTime': args.exptime,
              'priority': 1}
        cam.send_Event("startIntegration", **kw)
        LOGGER.info("Sending startIntergration: {}".format(kw))
        time.sleep(args.exptime)

        # Send startReadout Event after integration is finished
        kw['timeStamp'] = time.time()
        LOGGER.info("Sending startReadout")
        cam.send_Event('startReadout')
        time.sleep(args.sleeptime)

        # Send endReadout event
        kw['timeStamp'] = time.time()
        LOGGER.info("Sending endReadout")
        cam.send_Event('endReadout', **kw)
        time.sleep(0.1)

        # Send Measured exptime event
        kw['timeStamp'] = time.time()
        LOGGER.info("Sending Measured Exptime")
        cam.send_Event('shutterMotionProfile', measuredExposureTime=args.exptime+0.35)
        time.sleep(0.1)

        # end telemetry for Airmass using ATPtg.prospectiveTargetStatus
        # WARNING: Here we use a 1.001 factor simple to change by 0.001
        # the END values compared to the START values above
        kw = {'timestamp': time.time(),
              'ha': str(float(args.ha)*1.001),
              'airmass': args.airmass*1.001}
        ptg.send_Telemetry('prospectiveTargetStatus', **kw)
        LOGGER.info("Sending prospectiveTargetStatus {}:\n".format(ptg.get_myData()))

        # end telemetry for EL and AZ from the ATMCS.mountEncoders
        # WARNING: Here we use a 1.001 factor simple to change by 0.001
        # the END values compared to the START values above
        kw = {'timestamp': time.time(),
              'elevationCalculatedAngle': args.el*1.001,
              'azimuthCalculatedAngle': args.az*1.001}
        mcs.send_Telemetry('mountEncoders', **kw)
        LOGGER.info("Sending mountEncoders {}:\n".format(mcs.get_myData()))

        kw['timeStamp'] = time.time()
        LOGGER.info("Sending endOfImageTelemetry")
        cam.send_Event('endOfImageTelemetry', **kw)
        time.sleep(args.sleeptime)

    # Send the ACK
    cam.ackCommand('takeImages', camCommand.cmdId)
    camCommand.waitForCompletion_Command()
    LOGGER.info("Bye...")
