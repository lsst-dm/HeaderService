#!/usr/bin/env python

import time
import sys
import os
import logging
import HeaderService
import salpytools
import HeaderService.hutils as hutils
import HeaderService.hslib as hslib
import argparse
import socket
import math
import yaml
    
spinner = hutils.spinner

# Create a logger for all functions
LOGGER = hutils.create_logger(level=logging.NOTSET,name='HEADERSERVICE')

def cmdline():

    # 1. We make a proto-parse use to read in the default yaml
    # configuration file, Turn off help, so we print all options in response to -h
    conf_parser = argparse.ArgumentParser(add_help=False)
    conf_parser.add_argument("-c", "--config",help="HeaderService config file")
    args, remaining_argv = conf_parser.parse_known_args()
    conf_defaults = yaml.load(open(args.config))

    # 2. This is the main parser
    parser = argparse.ArgumentParser(description="HeaderService",
                                     # Inherit options from config_parser
                                     parents=[conf_parser])
    parser.add_argument("--vendor", action="store",default='ITL', 
                        help="CCD Vendor Name")
    parser.add_argument("--filepath", action="store",default=os.path.join(os.getcwd(),'DMHS_filerepo'),
                        help="Filepath where we write the headers")
    parser.add_argument("--tsleep", action="store",default=0.1, type=float, 
                        help="Sleep Time for loop")
    parser.add_argument("--start_state", action="store",default='OFFLINE', 
                        help="Initial start State of device")
    parser.add_argument("--send_efd_message", action="store_true",default=False, 
                        help="Send and EDF message as well?")
    #args = parser.parse_args()
    # Set the defaults of argparse using the values in the yaml config file
    parser.set_defaults(**conf_defaults)
    args = parser.parse_args(args=remaining_argv)

    # Get the channels we need to subscribe here
    #args.channels = hslib.get_telemetry_channels(args.telemetry,
    #                                             start_collection_event=args.start_collection_event,
    #                                             end_collection_event=args.end_collection_event)
    #print ("Will use:")
    #for k, v in vars(args).items():
    #    print ("   {}: {}".format(k, v))
    #    print ("-----------------------")
    return args


def run_enable(State,**kwargs):

    # Extract params from kwargs
    telemetry = kwargs.pop('telemetry')
    vendor    = kwargs.pop('vendor','ITL')
    filepath  = kwargs.pop('filepath','.')
    tsleep    = kwargs.pop('tsleep',0.1)
    start_collection_event = kwargs.pop('start_collection_event',None)
    end_collection_event   = kwargs.pop('end_collection_event',None)
    
    # Extract the unique channel by topic/device
    LOGGER.info("Extracting Telemetry channels from telemetry dictionary")
    channels = hslib.get_telemetry_channels(telemetry,
                                            start_collection_event=start_collection_event,
                                            end_collection_event=end_collection_event)

    # Subscribe to each of the channels we want to susbcribe and store
    # the connection in a dictionary
    LOGGER.info("*** Starting Connections for Meta-data ***")
    SAL_connection = hslib.subscribe_to_channels(channels,start=True)

    # Select the start_collection
    name_start = hslib.get_channel_name(start_collection_event)
    StartInt = SAL_connection[name_start]

    # Select the end_collection
    name_end = hslib.get_channel_name(end_collection_event)
    EndTelem = SAL_connection[name_end]
    
    # And the object to send DMHS messages
    dmhs = salpytools.DDSSend("atHeaderService")
    efd  = salpytools.DDSSend('efd')

    # Load up the header template
    HDR = HeaderService.HDRTEMPL_ATSCam(vendor=vendor)
    HDR.load_templates() # TODO: We should do this later ----

    # Make sure that we have a place to put the files
    if not os.path.exists(filepath):
        os.makedirs(filepath)
        LOGGER.info("Created dirname:{}".format(filepath))

    # Get the hostname and IP address
    ip_adress = socket.gethostbyname(socket.gethostname())

    # TODO: this should be configurable options
    # The user running the process
    USER = os.environ['USER']
    # The protocol
    PROTOCOL = 'scp'
    # --------------------------
    
    # For testing start ENABLE
    loop_n = 0
    while True:

        if State.current_state!='ENABLE':
            sys.stdout.flush()
            sys.stdout.write("Current State is {} [{}]".format(State.current_state,spinner.next()))
            sys.stdout.write('\r') 

        elif StartInt.newEvent:

            # Build the DATE of observation
            DATE_OBS = hutils.get_date_utc()

            sys.stdout.flush()
            LOGGER.info("Received: startIntegration Event")
            LOGGER.info("Extracting value for imageName")
            myData = StartInt.getCurrent()
            imageName = myData.imageName
            exptime = myData.exposureTime
            LOGGER.info("Received: imageName={}, exptime={}".format(imageName,exptime))

            # Construct the hdr and fits filename
            filename_HDR  = os.path.join(filepath,"{}.header".format(imageName))
            filename_FITS = "{}.fits".format(imageName)

            # Get the Target information
            LOGGER.info("Extracting Target information")
            myData = Target.getCurrent()
            ra,dec,angle,airmass = myData.ra, myData.decl, myData.angle, myData.airmass
            LOGGER.info("Received: RA={}, DEC={}, ANGLE={}, AIRMASS={}".format(ra,dec,angle,airmass))
            filter_name, grating = myData.filters, myData.grating
            LOGGER.info("Received: filter={}, grating={}".format(filter_name,grating))
            # For now -- we try to recover the zenith distance from the airmass 
            try:
                zd = (math.acos(1.0/airmass))*180./math.pi
            except:
                zd = -99.0

            # Get the readout
            LOGGER.info("Current State is {} -- waiting for Camera endOfImageTelemetry event".format(State.current_state))
            EndTelem.waitEvent()
            if EndTelem.newEvent:
                sys.stdout.flush()
                LOGGER.info("Received: endOfImageTelemetry Signal")

                # We get these after we get endOfImageTelemetry Signal
                # Exposure Time
                LOGGER.info("Extracting Actual Exposure time")
                myData = Exptime.getCurrent()
                measuredExptime = myData.measuredExposureTime
                LOGGER.info("Received: measuredExptime={}".format(measuredExptime))

                # Image paramters
                LOGGER.info("Extracting Image Parameters")
                myData = ImParam.getCurrent()
                overv, overh, preh = myData.overRows, myData.overCols,myData.preRows
                LOGGER.info("Received: overv={}, overh={}, preh={}".format(overv, overh, preh))

                # Manually Update a header param -- we need to move it a function soon
                # These ones were captured from DDS
                HDR.update_record('FILTER',filter_name, 'PRIMARY')
                HDR.update_record('GRATING',grating, 'PRIMARY')
                HDR.update_record('RA',ra,'PRIMARY')
                HDR.update_record('DEC',dec,'PRIMARY')
                HDR.update_record('ROTANGLE',angle,'PRIMARY')
                HDR.update_record('AIRMASS',airmass,'PRIMARY')
                HDR.update_record('RATEL',ra,'PRIMARY')
                HDR.update_record('DECTEL',dec,'PRIMARY')
                HDR.update_record('ZD', zd, 'PRIMARY')
                HDR.update_record('IMGNAME',imageName,'PRIMARY')
                HDR.update_record('EXPTIME',measuredExptime,'PRIMARY')
                HDR.update_record('OVERH',overh,'PRIMARY')
                HDR.update_record('OVERV',overv,'PRIMARY')
                HDR.update_record('PREH',preh,'PRIMARY')

                # These values are computed by the DMHS
                HDR.update_record('FILENAME',filename_FITS,'PRIMARY')
                HDR.update_record('DATE-OBS',DATE_OBS.fits,'PRIMARY')
                HDR.update_record('MJD-OBS',DATE_OBS.mjd,'PRIMARY')
                # The creation date -- now!!
                DATE = hutils.get_date_utc()
                HDR.update_record('DATE',DATE.fits,'PRIMARY')
                HDR.update_record('MJD',DATE.mjd,'PRIMARY')
                # The obs-nite
                HDR.update_record('OBS-NITE',hutils.get_obsnite(),'PRIMARY')
                # Write the header 
                HDR.write_header(filename_HDR, newline=False)
                LOGGER.info("Wrote header to: {}".format(filename_HDR))
                # Get the md5 for the header file
                md5value = hutils.md5Checksum(filename_HDR) #,blocksize=1024*512):
                bytesize = os.path.getsize(filename_HDR)
                LOGGER.info("Got MD5SUM: {}".format(md5value))
                # Now we publish filename and MD5
                # Build the kwargs
                kw = {'Byte_Size':bytesize,
                      'Checksum':md5value,
                      'Generator':'AT',
                      'Mime':'FITS',
                      'URL': "{}://{}@{}:{}".format(PROTOCOL,USER,ip_adress,filename_HDR),
                      #'URL': "{}".format(os.path.abspath(filename_HDR)),
                      'Version': 1,
                      'priority':1,
                      }
                dmhs.send_Event('LargeFileObjectAvailable',**kw)
                LOGGER.info("Sent LargeFileObjectAvailable: {}".format(kw))
                if args.send_efd_message:
                    efd.send_Event('LargeFileObjectAvailable',**kw)
                EndTelem.newEvent = False
                LOGGER.info("------------------------------------------")

        else:
            sys.stdout.flush()
            sys.stdout.write("Current State is {} -- wating for startIntegration Event...[{}]".format(State.current_state,spinner.next()))
            sys.stdout.write('\r')
            time.sleep(tsleep)

        time.sleep(tsleep)
        loop_n +=1    


if __name__ == "__main__":

    # Get the args from the command-line
    args = cmdline()

    w = hslib.HSworker(**args.__dict__)
    w.get_channels()
    #w.init_State()
    exit()

    # to get them as dict
    # myfunction(**args.__dict__)
    # dict = vars(args)

    # Init the device and send the current state vis SummaryState.
    # This needs to be done before we star the SAL controller thread,
    # as they use the DeviveState object for the current state
    State = salpytools.DeviceState(default_state=args.start_state)
    State.send_logEvent('SummaryState')
    
    # Create threads for the controller we want to listen to
    controller_list = ['enterControl',
                       'exitControl',
                       'start',
                       'standby',
                       'enable',
                       'disable']
    tControl = {}
    for ctrl_name in controller_list:
        tControl[ctrl_name] = salpytools.DDSController(ctrl_name,State=State)
        tControl[ctrl_name].start()

    #run_enable(State,
    #           telemetry=args.telemetry,
    #           vendor=args.vendor,
    #           filepath=args.filepath,
    #           tsleep=args.tsleep,
    #           start_collection_event=args.start_collection_event,
    #           end_collection_event=args.end_collection_event,
    #           )
    #run_enable(State,**args.__dict__)
