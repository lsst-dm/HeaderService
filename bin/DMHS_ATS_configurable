#!/usr/bin/env python

import time
import sys
import os
import logging
import HeaderService
import HeaderService.SAL_tools as SAL_tools
import HeaderService.hutils as hutils
import argparse
import socket
import math
    
spinner = hutils.spinner

def cmdline():

    import argparse
    import yaml
    
    # 1. We make a proto-parse use to read in the default yaml
    # configuration file, Turn off help, so we print all options in response to -h
    conf_parser = argparse.ArgumentParser(add_help=False)
    conf_parser.add_argument("-c", "--config",help="HeaderService config file")
    args, remaining_argv = conf_parser.parse_known_args()
    conf_defaults = yaml.load(open(args.config))

    # 2. This is the main parser
    parser = argparse.ArgumentParser(description="HeaderService",
                                     # Inherit options from config_parser
                                     parents=[conf_parser])
    parser.add_argument("--vendor", action="store",default='ITL', 
                        help="CCD Vendor Name")
    parser.add_argument("--filepath", action="store",default=os.path.join(os.getcwd(),'DMHS_filerepo'),
                        help="Filepath where we write the headers")
    parser.add_argument("--tsleep", action="store",default=0.1, type=float, 
                        help="Sleep Time for loop")
    parser.add_argument("--start_state", action="store",default=None, 
                        help="Initial start State of device")
    parser.add_argument("--send_efd_message", action="store_true",default=False, 
                        help="Send and EDF message as well?")
    #args = parser.parse_args()
    # Set the defaults of argparse using the values in the yaml config file
    parser.set_defaults(**conf_defaults)
    args = parser.parse_args(args=remaining_argv)

    # Get the channels we need to subscribe
    args.channels = get_telemetry_channels(args.telemetry,
                                           start_collection_event=args.start_collection_event,
                                           end_collection_event=args.end_collection_event)
    print ("Will use:")
    for k, v in vars(args).items():
        print ("   {}: {}".format(k, v))
    exit()
    return args

def get_telemetry_channels(telem,start_collection_event=None,end_collection_event=None):
    ''' Get the unique telemetry channels that we need to subscribe to'''

    # ----------------------------------------------------------
    # TODO: This function need to be moved to an outside library
    # ----------------------------------------------------------


    # Add 'start_collection_event' and 'end_collection_event' to
    # telemetry to make sure we add them to the channels
    #if start_collection_event:
    #    telem['start_collection_event'] = start_collection_event
    #if end_collection_event:
    #    telem['end_collection_event'] = start_collection_event
    channels = {}
    for key in telem:
        # Make the name of the channel unique by appending device
        c = {'device':telem[key]['device'],    
             'topic': telem[key]['topic'],
             'Stype' :telem[key]['Stype']}
        name = '{}_{}'.format(c['device'],c['topic'])
        if name not in channels.keys():
            channels[name] = c

    #for k, v in channels.items():
    #    print ("{}: {}".format(k, v))
    return channels

def run_enable(State,telemetry={},vendor='ITL',filepath='.',tsleep=0.1, start_state='OFFLINE'):

    # TODO: Rename this function and probably pass all of the args or kwargs

    # Extract the unique channel by topic/device
    channels = get_telemetry_channels(telemetry)

    # Subscribe to each of the channels we want to susbcribe and store
    # the connection in a dictionary
    SAL_connection = {}
    for name, c in channels.items():
        SAL_connection[name] = SAL_tools.DDSSubcriber(c['device'],c['topic'],Stype=c['Stype'])
        SAL_connection[name].start()

    # And the object to send DMHS messages
    dmhs = SAL_tools.DDSSend("atHeaderService")
    efd  = SAL_tools.DDSSend('efd')

    # Load up the header template
    HDR = HeaderService.HDRTEMPL_ATSCam(vendor=vendor)
    HDR.load_templates() # TODO: We should do this later ----
    LOGGER = HDR.logger


    # Make sure that we have a place to put the files
    if not os.path.exists(filepath):
        os.makedirs(filepath)
        LOGGER.info("Created dirname:{}".format(filepath))

    # Get the hostname and IP address
    ip_adress = socket.gethostbyname(socket.gethostname())

    # TODO: this should be configurable options
    # The user running the process
    USER = os.environ['USER']
    # The protocol
    PROTOCOL = 'scp'
    # --------------------------
    
    # For testing start ENABLE
    loop_n = 0
    while True:

        if State.current_state!='ENABLE':
            sys.stdout.flush()
            sys.stdout.write("Current State is {} [{}]".format(State.current_state,spinner.next()))
            sys.stdout.write('\r') 

        elif StartInt.newEvent:

            # Build the DATE of observation
            DATE_OBS = hutils.get_date_utc()

            sys.stdout.flush()
            LOGGER.info("Received: startIntegration Event")
            LOGGER.info("Extracting value for imageName")
            myData = StartInt.getCurrent()
            imageName = myData.imageName
            exptime = myData.exposureTime
            LOGGER.info("Received: imageName={}, exptime={}".format(imageName,exptime))

            # Construct the hdr and fits filename
            filename_HDR  = os.path.join(filepath,"{}.header".format(imageName))
            filename_FITS = "{}.fits".format(imageName)

            # Get the Target information
            LOGGER.info("Extracting Target information")
            myData = Target.getCurrent()
            ra,dec,angle,airmass = myData.ra, myData.decl, myData.angle, myData.airmass
            LOGGER.info("Received: RA={}, DEC={}, ANGLE={}, AIRMASS={}".format(ra,dec,angle,airmass))
            filter_name, grating = myData.filters, myData.grating
            LOGGER.info("Received: filter={}, grating={}".format(filter_name,grating))
            # For now -- we try to recover the zenith distance from the airmass 
            try:
                zd = (math.acos(1.0/airmass))*180./math.pi
            except:
                zd = -99.0

            # Get the readout
            LOGGER.info("Current State is {} -- waiting for Camera endOfImageTelemetry event".format(State.current_state))
            EndTelem.waitEvent()
            if EndTelem.newEvent:
                sys.stdout.flush()
                LOGGER.info("Received: endOfImageTelemetry Signal")

                # We get these after we get endOfImageTelemetry Signal
                # Exposure Time
                LOGGER.info("Extracting Actual Exposure time")
                myData = Exptime.getCurrent()
                measuredExptime = myData.measuredExposureTime
                LOGGER.info("Received: measuredExptime={}".format(measuredExptime))

                # Image paramters
                LOGGER.info("Extracting Image Parameters")
                myData = ImParam.getCurrent()
                overv, overh, preh = myData.overRows, myData.overCols,myData.preRows
                LOGGER.info("Received: overv={}, overh={}, preh={}".format(overv, overh, preh))

                # Manually Update a header param -- we need to move it a function soon
                # These ones were captured from DDS
                HDR.update_record('FILTER',filter_name, 'PRIMARY')
                HDR.update_record('GRATING',grating, 'PRIMARY')
                HDR.update_record('RA',ra,'PRIMARY')
                HDR.update_record('DEC',dec,'PRIMARY')
                HDR.update_record('ROTANGLE',angle,'PRIMARY')
                HDR.update_record('AIRMASS',airmass,'PRIMARY')
                HDR.update_record('RATEL',ra,'PRIMARY')
                HDR.update_record('DECTEL',dec,'PRIMARY')
                HDR.update_record('ZD', zd, 'PRIMARY')
                HDR.update_record('IMGNAME',imageName,'PRIMARY')
                HDR.update_record('EXPTIME',measuredExptime,'PRIMARY')
                HDR.update_record('OVERH',overh,'PRIMARY')
                HDR.update_record('OVERV',overv,'PRIMARY')
                HDR.update_record('PREH',preh,'PRIMARY')

                # These values are computed by the DMHS
                HDR.update_record('FILENAME',filename_FITS,'PRIMARY')
                HDR.update_record('DATE-OBS',DATE_OBS.fits,'PRIMARY')
                HDR.update_record('MJD-OBS',DATE_OBS.mjd,'PRIMARY')
                # The creation date -- now!!
                DATE = hutils.get_date_utc()
                HDR.update_record('DATE',DATE.fits,'PRIMARY')
                HDR.update_record('MJD',DATE.mjd,'PRIMARY')
                # The obs-nite
                HDR.update_record('OBS-NITE',hutils.get_obsnite(),'PRIMARY')
                # Write the header 
                HDR.write_header(filename_HDR, newline=False)
                LOGGER.info("Wrote header to: {}".format(filename_HDR))
                # Get the md5 for the header file
                md5value = hutils.md5Checksum(filename_HDR) #,blocksize=1024*512):
                bytesize = os.path.getsize(filename_HDR)
                LOGGER.info("Got MD5SUM: {}".format(md5value))
                # Now we publish filename and MD5
                # Build the kwargs
                kw = {'Byte_Size':bytesize,
                      'Checksum':md5value,
                      'Generator':'AT',
                      'Mime':'FITS',
                      'URL': "{}://{}@{}:{}".format(PROTOCOL,USER,ip_adress,filename_HDR),
                      #'URL': "{}".format(os.path.abspath(filename_HDR)),
                      'Version': 1,
                      'priority':1,
                      }
                dmhs.send_Event('LargeFileObjectAvailable',**kw)
                LOGGER.info("Sent LargeFileObjectAvailable: {}".format(kw))
                if args.send_efd_message:
                    efd.send_Event('LargeFileObjectAvailable',**kw)
                EndTelem.newEvent = False
                LOGGER.info("------------------------------------------")

        else:
            sys.stdout.flush()
            sys.stdout.write("Current State is {} -- wating for startIntegration Event...[{}]".format(State.current_state,spinner.next()))
            sys.stdout.write('\r')
            time.sleep(tsleep)

        time.sleep(tsleep)
        loop_n +=1    

if __name__ == "__main__":

    # Get the args from the command-line
    args = cmdline()

    # Init the device and send the current state vis SummaryState.
    # This needs to be done before we star the SAL controller thread,
    # as they use the DeviveState object for the current state
    State = SAL_tools.DeviceState()
    State.send_logEvent('SummaryState')
    
    # Create threads for the controller we want to listen to
    controller_list = ['enterControl',
                       'exitControl',
                       'start',
                       'standby',
                       'enable',
                       'disable']
    tControl = {}
    for ctrl_name in controller_list:
        tControl[ctrl_name] = SAL_tools.DDSController(ctrl_name,State=State)
        tControl[ctrl_name].start()

    # Set the initial state
    if args.start_state:
        State.current_state = args.start_state

    run_enable(State,telemetry=args.telemetry,vendor=args.vendor,filepath=args.filepath,tsleep=args.tsleep)
    
